(** OCaml bindings to QuickJS.
    @see <https://bellard.org/quickjs/quickjs.html>
   *)

(** {1 type} *)

type runtime
(** [runtime] represents a Javascript runtime corresponding to an object heap.
    Several runtimes can exist at the same time but they cannot exchange
    objects. Inside a given runtime, no multi-threading is supported.
    *)

type context
(** [context] represents a Javascript context (or Realm). Each context has
    its own global objects and system objects. There can be several contexts
    per runtime and they can share objects, similar to frames of the same
    origin sharing Javascript objects in a web browser.
    *)

type value
(** [value] represents a Javascript value which can be a primitive type or an
    object.
    *)

type bytecode
(** [bytecode] represents the bytecode which is generated by {! compile} and
    can be executed with {! execute}.
    *)

type js_exn = value
(** JS can throw any [value] *)

type 'a or_js_exn = ('a, js_exn) result

(** {2 raw represent} *)

val get_raw_runtime : runtime -> Quickjs_raw.js_runtime_ptr

val get_raw_context : context -> Quickjs_raw.js_context_ptr

val get_raw_value : value -> Quickjs_raw.js_value

val get_raw_bytecode : bytecode -> Quickjs_raw.js_value

(** {1 runtime} *)

val new_runtime : unit -> runtime

val set_memory_limit : runtime -> Unsigned.size_t -> unit

val set_gc_threshold : runtime -> Unsigned.size_t -> unit

val run_gc : runtime -> unit

val compute_memory_usage : runtime -> Quickjs_raw.MemoryUsage.t

val memory_usage_to_string : Quickjs_raw.MemoryUsage.t -> string

type interrupt_handler = runtime -> bool
(** [interrupt_handler runtime], return false will interrupt runtime *)

val set_interrupt_handler : runtime -> interrupt_handler -> unit

(** {1 context} *)

val new_context : runtime -> context

val get_runtime : context -> runtime

val set_max_stack_size : context -> Unsigned.size_t -> unit

val enable_bignum_ext : context -> unit
(** enable math mode support.
    @see <https://bellard.org/quickjs/jsbignum.html#Math-mode>
    *)

val disable_bignum_ext : context -> unit

type js_func = context -> value -> value list -> value
(** [context -> this -> arguments] *)

val add_func : context -> js_func -> string -> int -> value or_js_exn
(** [add_func context func name argc] export [func] to [context]
    return the js function created
    *)

(** {1 value} *)

(** convert [value] to ocaml data *)
module Value : sig
  module New : sig
    val jsval : context -> Quickjs_raw.js_value -> value

    val bool : context -> bool -> Quickjs_raw.js_value

    val string : context -> string -> Quickjs_raw.js_value

    val int32 : context -> Int32.t -> Quickjs_raw.js_value

    val int64 : context -> Int64.t -> Quickjs_raw.js_value

    val float : context -> float -> Quickjs_raw.js_value

    val big_int64 : context -> Int64.t -> Quickjs_raw.js_value

    val big_uint64 : context -> Unsigned.uint64 -> Quickjs_raw.js_value
  end

  module Is : sig
    val uninitialized : value -> bool

    val null : value -> bool

    val undefined : value -> bool

    val bool : value -> bool

    val number : value -> bool

    val string : value -> bool

    val symbol : value -> bool

    val array : value -> bool

    val js_object : value -> bool

    val js_function : value -> bool

    val constructor : value -> bool

    val error : value -> bool

    val js_exception : value -> bool

    val big_int : value -> bool

    val big_float : value -> bool

    val big_decimal : value -> bool

    val instance_of : value -> value -> bool
  end

  module To : sig
    val string_value : value -> value

    val string : value -> string option
    (** return [None] if value return a null string *)

    val bool : value -> bool or_js_exn

    val int32 : value -> int32 or_js_exn

    val uint32 : value -> Unsigned.uint32 or_js_exn

    val int64 : value -> int64 or_js_exn

    val float : value -> float or_js_exn
  end
end

val check_exception : value -> value or_js_exn
(** [check_exception value] get exception obj from context.
    {b Cannot be called twice with the same [value]}.
{[
let _ =
  let open Quickjs in
  let r = eval_unsafe script in
  match check_exception r with
  | Ok obj -> "it is safe to use " ^ (Value.to_string obj)
  | Error js_exn -> "eval_unsafe throw " ^ (Value.to_string js_exn)
]}
*)

(** {1 eval} *)

type eval_type =
  [ `GLOBAL  (** global code (default) *)
  | `MODULE  (** module code *)
  ]

type eval_flag =
  [ `STRICT  (** force 'strict' mode *)
  | `STRIP  (** force 'strip' mode *)
  | `BACKTRACE_BARRIER
    (** don't include the stack frames before this eval in the Error() backtraces *)
  ]

val eval
  :  ?typ:eval_type ->
  ?flags:eval_flag list ->
  ?ctx:context ->
  string ->
  value or_js_exn
(** [eval ~typ ~flags ~ctx script] *)

val eval_unsafe
  :  ?typ:eval_type ->
  ?flags:eval_flag list ->
  ?ctx:context ->
  string ->
  value
(** [eval_unsafe ~typ ~flags ~ctx script], you must check exception by yourself. {!val:check_exception} *)

val compile
  :  ?typ:eval_type ->
  ?flags:eval_flag list ->
  ?ctx:context ->
  string ->
  bytecode or_js_exn
(** [compile ~typ ~flags ~ctx script] *)

val execute : bytecode -> value or_js_exn
(** [execute bytecode] *)
